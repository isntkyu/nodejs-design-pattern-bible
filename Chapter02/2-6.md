# 2-6 ESM: ECMAScript 모듈

static.
import가 가장 상위레벨 제어흐름 구문의 바깥쪽에 기술됨.

commonjs 에서는

```js
if (condition) {
  module = require("");
}
```

위처럼 사용하는게 전혀 문제가 되지않음.

하지만 정적 임포트는 트리셰이킹 가능.

---

## 2-6-1 Node.js 에서의 ESM 사용

ES 모듈 받을 방법은

- .mjs 확장자
- package.json 의 type: module

---

## 2-6-2 exports 와 imports 지정하기

ES모듈에서는 모든 것이 기본적으로 프라이빗하며 export 된 개체들만 접근 가능합니다.

---

## 2-6-3 export 와 import 기본값 설정하기

export default (중괄호없이 import)
트리셰이킹 어려움
명확히 한가지 기능이면 default 사용하되 export 사용이 일반적으로 좋음

---

## 2-6-4 혼합된 export

import a, {b} from '';

---

## 2-6-5 모듈 식별자

---

## 2-6-6 비동기 임포트

- 모듈 식별자는 실행 중에 생성될 수 없다.
- 임포트는 모든 파일의 최상위에 선언되며 제어구문에 포함될 수 없다.

import() 연산자는 모듈 식별자를 인자로 취하고 모듈 객체를 프라미스로 반환하는 함수

import().then()

---

## 2-6-7 모듈 적재 이해하기

### 로딩단계

인터프리터의 목표는 필요한 모든 모듈의 그래프(종속성 그래프)를 만들어 내는 것입니다.

인터프리터는 진입점에서부터 import 구문을 재귀적인 dfs 로 찾습니다.

- 1단계 생성또는 파싱) 모든 import 구문을 찾고 모든 모듈내용을 적재
- 2단계 인스턴스화) 익스포트된 모든 개체들에 대해 명명된 참조를 메모리에 유지. 또한 모든 import 및 export 에 대한 참조가 생성되어 이들 간의 종속성 관계를 추적합니다. 이단계에서 어떠한 js 코드도 실행되지 않습니다.
- 3단계 평가) Node.js 는 마지막으로 코드를 실행하여 이전에 인스턴스화된 모든 개체가 실제 값을 얻도록 합니다.

**ESM에선 3단계가 완전 분리되어있다. 모든 종속성이 오나전해져야 코드가 실행된다.**

---

## 2-6-8 모듈의 수정

ESM 환경에서 몽키패치는 복잡하고 신뢰하기 힘들다.
jest 테스트 프레임워크가 es 모듈을 모킹할 수 잇도록 제공
