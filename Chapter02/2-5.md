# 2-5 모듈 정의 패턴

---

## 2-5-1 exports 지정하기(Named exports)

public API 를 공개하는 가장 기본적인 방법은 exports에 할당하는 것.

exports에서 참조하는 객체에 공개할 모든 값을 할당한다.
그 결과 공개된 객체는 일련의 관련 기능에 대한 컨테이너 또는 네임스페이스가 된다.

---

## 2-5-2 함수 내보내기

가장 일반적인 모듈 정의 패턴은 module.exports 변수 전체를 함수로 재할당 하는것.

```js
module.exports = () => {};
```

주요 장점

- 모듈에 대한 명확한 진입점 제공하는 단일 기능을 제공.
- 이해와 사용을 단순화함.
- 최소한 노출의 원리.
- 서브스택 패턴

```js
const logger = require("logger");

logger("log");
```

위의 형태로 사용가능.
단일 기능에 중점을 두는 완벽한 방법이며 이 외의 보조사항은 exports된 함수의 속성으로 노출

Node.js의 모듈성은 한 가지 책임 원칙을 강력히 권장한다.

---

## 2-5-3 클래스 내보내기

클래스를 내보내는 모듈은 함수를 내보내는 모듈이 특화된 것이다.

생성자를 사용하여 새 인스턴스를 만들 수 있게 하면서 프로토타입을 확장하고 새로운 클래스를 만들 수 있는 기능을 제공

> module.exports = CLASSNAME

---

## 2-5-4 인스턴스 내보내기

require() 캐싱 메커니즘을 이용해서 생성자나 팩토리로부터 다른 모듈간에 공유할 수 있는 상태 저장 인스턴스를 쉽게 정의할 수 있다.

> module.exports = new CLASSNAME('')

모듈이 캐시되기 때문에 이 모듈을 require 하면 동일한 객체를 받아 공유하게 된다.

**싱글톤** 을 만드는 것과 매우 유사하다.

새로운 인스턴스를 만드는 것을 막지는 못함

export 된 인스턴스의 constructor 속성에 접근할 수 있기 때문.

> const customLogger = new Logger.constructor('custom')

신중하거나 사용하지 않는 것이 안전.

---

## 2-5-5 다른 모듈 또는 전역 범위(global scope) 수정

모듈이 아무것도 내보내지 않을 수 있음.

**몽키 패치** : 모듈이 전역 범위의 다른 모듈이나 객체를 수정할 수 있음.
런타임시에 기존 객체를 수정하거나 동작을 변경하는 임시 수정 적용 관행.
