# 1-2 Node.js는 어떻게 작동하는가

Node.js 가 가진 비동기 특성의 핵심인 리액터 패턴
단일 스레드 아키텍쳐와 논 블로킹 I/O

---

## 1-2-1 I/O는 느리다

RAM에 접근하는건 빠르지만 디스크와 네트워크에 접근하는 것은 느림.
대역폭도 (GB/s) RAM 전송률은 일관되지만 디스크나 네트워크는 다양함.

사람이 사용할 때의 많은 상황들에서 I/O의 속도와 빈도는 느릴 수 있다.

---

## 1-2-2 블로킹 I/O

전통적인 블로킹 I/O 는 작업이 완료될 때까지 스레드의 실행을 차단한다.

```
data = socket.read();
data가 사용 가능 할 때까지 스레드를 블로킹
```

전통적인 해결법은 개별 쓰레드, 여러 프로세스 사용하는 것.

비용이 많이 듦. (메모리나 cpu)

---

## 1-2-3 논 블로킹 I/O

호출 순간에 데이터를 즉시 반환하지만 사용가능한 결과가 아닐 경우엔 미리 정의된 상수를 반환하여 사용 가능한 데이터가 없다는 것을 알린다.

가장 기본적인 패턴은 실제 데이터가 반환될 때까지 루프 내에서 리로스를 적극 Polling 하는 것.
이것은 바쁜 대기(busy-waiting)이라고 부른다.

바쁜대기는 아무튼 여전히 효율적인 방법은 아님 엄청난 CPU 낭비를 초래함.

---

## 1-2-4 이벤트 디멀티플렉싱

운영체제에서 논블로킹 리소스를 효율적으로 처리하기위한 메커니즘 제공함

- 동기 이벤트 디멀티플렉서
- 이벤트 통지 인터페이스

멀티플렉싱: 통신 용어로써 여러 신호를 하나로 합성하여 쉽게 전달.
디멀티플렉싱: 원래 구성으로 다시 분할.

동기이벤트 디멀티플렉서는 여러 리소스 관찰하다가 연산(읽기, 쓰기)이 완료되었을 때 새로운 이벤트를 반환함.
즉, 새로운 이벤트가 있을 때까지 블로킹.

반환된 이벤트가 처리되고 이 때는 각 이벤트와 관련된 리소스는 읽은 준비 및 차단되지 않는 것이 보장된다.
모든 이벤트가 처리되고 나면, 다시 이벤트 디멀티플렉서가 이벤트를 반환할 때까지 블로킹함.

> **이벤트 루프**

![[스크린샷 2022-08-17 오후 4.55.44.png]]

---

## 1-2-5 리액터 패턴

각 I/O 작업에 연관된 핸들러를 갖는다. Node.js 에서의 핸들러는 콜백 함수. (핸들러를 콜백함수로 대체해서 요약할거임)

콜백함수는 이벤트가 생성되고 이벤트 루프에 의해 처리되는 즉시 호출.

![[스크린샷 2022-08-17 오후 5.03.48.png]]

1. 애플리케이션이 이벤트 디멀티플렉서에 요청 전달

   - 애플리 케이션은 작업 완료되었을 때 호출될 콜백함수를 명시.
   - 이 과정은 논 블로킹 호출이며 제어권은 애플리케이션으로 즉시반환.

2. 이벤트 디멀티플렉서는 이벤트 큐에 이벤트 작업을 집어 넣는다.
3. 이벤트 루프가 이벤트 큐의 항목들을 순환한다.
4. 각 이벤트와 관련된 콜백함수 호출됨.
5. 핸들러 실행 완료되면 이벤트 루프에 제어권 돌려주고 이 도중에 다른 비동기 작업을 요청할 수 있다. ( 이벤트 디멀티플렉서에 새로운 항목을 추가한다는 뜻 )
6. 이벤트 큐의 모든게 처리되면 이벤트 루프는 이벤트디멀티플렉서에서 블로킹(새 이벤트가 있을 때까지)

---

## 1-2-6 Libuv, Node.js의 I/O 엔진

Libuv는 node.js 하위 수준의 i/o 엔진을 대표함.
기본 시스템호출을 추상화 하고 리액터 패턴을 구현하고 있음.

이벤트 루프의 생성, 이벤트 큐의 관리, 비동기i/o 작업 실행등의 API 제공.

---

## 1-2-7 Node.js를 위한 구성

리액터 패턴과 Libuv외에 Node.js 전체 플랫폼을 구축하려면 3개 구성이 더 필요하다.

- libuv와 다른 저수준 기능을 랩핑하고 표출시키기 위한 바인딩세트
- V8
- 고수준 Node.js APi 를 구현하는 코어 JS 라이브러리
