## 12 확장성과 아키텍처 패턴

### 12-1-1 Node.js 애플리케이션 확장

논블로킹 i/o 패러다임 덕분이 동시 요청을 처리하는 리소스 사용 최적화  
적당한 수의 요청(일반적으로 초당 수백개)를 처리할 때 훌륭.  
i/o 바인딩 작업에 특히 능함.(파일 시스템 및 네트워크 읽기쓰기)  
cpu바운드(데이터가공)이 아님.  

결국 프로세스를 확대해야할 필요가 있다.

### 12-1-2 확장성 3차원

첫 번 째 기본 원칙: 부하분산

*스케일큐브*
- x축: 복제 (인스턴스 늘리기)
- y축: 서비스/기능별 분해
- z축: 데이터 파티셔닝

---

## 12-2 복제 및 로드 밸런싱

멀티 스레드를 사용하는 전통적인 웹 서버는 사용 가능한 모든 프로세스와 메모리를 사용하여 모든 능력을 활용할 수 있다.  
반대로 Node.js는 빨리 확장되어야한다.

하지만 가용성 및 내결함성에 유익하다.
확장을 고려해서 애플리케이션을 설계해야 한다.

> 공유할 수 없는 리소스에 의존하지 않도록 해야합니다.

(ex) 메모리, 디스크 사용 등 지양

### 12-2-1 클러스터 모듈

마스터는 cpu 수만큼 작업 프로세스를 생성할 수 있으며, 요청을 받아서 로드밸런싱 하는 역할이다.
(라운드로빈 로드밸런싱 알고리즘)


*autocannon: 네트워크 벤치마킹 도구*


- 1차 app.js 부하 측정
  ┌─────────┬────────┬────────┬────────┬────────┬───────────┬──────────┬─────────┐
  │ Stat    │ 2.5%   │ 50%    │ 97.5%  │ 99%    │ Avg       │ Stdev    │ Max     │
  ├─────────┼────────┼────────┼────────┼────────┼───────────┼──────────┼─────────┤
  │ Latency │ 286 ms │ 578 ms │ 619 ms │ 625 ms │ 569.54 ms │ 81.24 ms │ 1205 ms │
  └─────────┴────────┴────────┴────────┴────────┴───────────┴──────────┴─────────┘
  ┌───────────┬─────────┬─────────┬─────────┬─────────┬─────────┬───────┬─────────┐
  │ Stat      │ 1%      │ 2.5%    │ 50%     │ 97.5%   │ Avg     │ Stdev │ Min     │
  ├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────┼─────────┤
  │ Req/Sec   │ 325     │ 325     │ 342     │ 348     │ 341.6   │ 6.64  │ 325     │
  ├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────┼─────────┤
  │ Bytes/Sec │ 45.2 kB │ 45.2 kB │ 47.6 kB │ 48.4 kB │ 47.5 kB │ 924 B │ 45.2 kB │
  └───────────┴─────────┴─────────┴─────────┴─────────┴─────────┴───────┴─────────┘
``

기본적인 클러스터링 

```js
if (cluster.isMaster) {
    // fork()
} else {
    // do work
}
```

c내부적으로 cluster.fork() 함수는 child_process.fork() 를 사용한다.  
그러므로 마스터와 워커간의 통신 채널도 있다.  
모든 메시지를 브로드캐스팅하는 것이 가능하다.  
> Object.values(cluster.workers).forEach(worker => worker.send('message from master')


- 2차 app.js (8코어) 부하 측정
  ┌─────────┬───────┬────────┬────────┬────────┬───────────┬───────────┬─────────┐  
  │ Stat    │ 2.5%  │ 50%    │ 97.5%  │ 99%    │ Avg       │ Stdev     │ Max     │  
  ├─────────┼───────┼────────┼────────┼────────┼───────────┼───────────┼─────────┤  
  │ Latency │ 61 ms │ 163 ms │ 295 ms │ 595 ms │ 173.34 ms │ 144.28 ms │ 2494 ms │  
  └─────────┴───────┴────────┴────────┴────────┴───────────┴───────────┴─────────┘  
  ┌───────────┬────────┬────────┬────────┬────────┬────────┬─────────┬────────┐  
  │ Stat      │ 1%     │ 2.5%   │ 50%    │ 97.5%  │ Avg    │ Stdev   │ Min    │  
  ├───────────┼────────┼────────┼────────┼────────┼────────┼─────────┼────────┤  
  │ Req/Sec   │ 980    │ 980    │ 1168   │ 1235   │ 1141.6 │ 83.17   │ 980    │  
  ├───────────┼────────┼────────┼────────┼────────┼────────┼─────────┼────────┤  
  │ Bytes/Sec │ 136 kB │ 136 kB │ 162 kB │ 172 kB │ 159 kB │ 11.6 kB │ 136 kB │  
  └───────────┴────────┴────────┴────────┴────────┴────────┴─────────┴────────┘  

3배가량 성능향상  

- Node.js는 작업자 수를 관리해주지 않기 때문에, 비정상 종료나 에러시 작업자를 늘려주는 코드를 직접 첨가함으로서 가용성 유지

#### 다운타임 없이 애플리케이션 재시작하기
  for 문으로 워커들을 돌면서 일일이 disconnect 후 갈아끼운다


---

## 12-2-2 상태 저장 통신 다루기

PostgreSQL, MongoDB, CouchDB 혹은 Redis 를 통한 상태공유

결국 공유저장소 사용.  

공유 저장소 사용에 많은 리소스가 들 경우엔 고정 로드 밸런싱

*고정 로드 밸런싱*  

세션과 관련된 모든 요청을 항상 동일한 앱 인스턴스로 라우팅
즉, 한 세션은 한 인스턴스와 고정 매핑  (소켓 통신엔 유용)


---

## 12-2-3 역방향 프록시 확장

클러스터 사용의 대안으로, 다른 포트 및 머신에서 앱을 실행하고  
역방향 프록시를 사용하여 트래픽 분산.

Node.js에서는 클러스터 모듈 대신 이 접근을 사용해야 하는 이유.

- 여러 프로세스 뿐 아니라 여러 시스템에 부하 분산 가능
- 시장에서 가장 널리 사용되는 역방향 프록시는 고정 로드 밸런싱을 지원
- 언어, 플랫폼에 무관
- 강력신 로드밸럭싱 알고리즘 선택 가능
- url재작성, 캐싱, ssl 종료 지점, 보안 등 강력한 기능과 정적 파일 제공 등으 ㅣ완전한 웹서버 기능 제공

클러스터와 결합도 가능

---

nodejs 기반: forever, pm2

os 기반 모니터: systemd

고급 모니터링 솔루션: monit, supervisord

컨테이너: 쿠버네티스, 도커 스웜


---

## 12-2-4 동적 수평 확장

*서비스 레지스트리*

로드밸런서가 동적 확장에 필요한 토폴로지를 읽어올 수 있는 저장소  
ex) Consul

