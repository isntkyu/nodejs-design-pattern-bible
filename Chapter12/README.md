## 12 확장성과 아키텍처 패턴

### 12-1-1 Node.js 애플리케이션 확장

논블로킹 i/o 패러다임 덕분이 동시 요청을 처리하는 리소스 사용 최적화  
적당한 수의 요청(일반적으로 초당 수백개)를 처리할 때 훌륭.  
i/o 바인딩 작업에 특히 능함.(파일 시스템 및 네트워크 읽기쓰기)  
cpu바운드(데이터가공)이 아님.  

결국 프로세스를 확대해야할 필요가 있다.

### 12-1-2 확장성 3차원

첫 번 째 기본 원칙: 부하분산

*스케일큐브*
- x축: 복제 (인스턴스 늘리기)
- y축: 서비스/기능별 분해
- z축: 데이터 파티셔닝

---

## 12-2 복제 및 로드 밸런싱

멀티 스레드를 사용하는 전통적인 웹 서버는 사용 가능한 모든 프로세스와 메모리를 사용하여 모든 능력을 활용할 수 있다.  
반대로 Node.js는 빨리 확장되어야한다.

하지만 가용성 및 내결함성에 유익하다.
확장을 고려해서 애플리케이션을 설계해야 한다.

> 공유할 수 없는 리소스에 의존하지 않도록 해야합니다.

(ex) 메모리, 디스크 사용 등 지양

### 12-2-1 클러스터 모듈

마스터는 cpu 수만큼 작업 프로세스를 생성할 수 있으며, 요청을 받아서 로드밸런싱 하는 역할이다.
(라운드로빈 로드밸런싱 알고리즘)


*autocannon: 네트워크 벤치마킹 도구*


- 1차 app.js 부하 측정
  ┌─────────┬────────┬────────┬────────┬────────┬───────────┬──────────┬─────────┐
  │ Stat    │ 2.5%   │ 50%    │ 97.5%  │ 99%    │ Avg       │ Stdev    │ Max     │
  ├─────────┼────────┼────────┼────────┼────────┼───────────┼──────────┼─────────┤
  │ Latency │ 286 ms │ 578 ms │ 619 ms │ 625 ms │ 569.54 ms │ 81.24 ms │ 1205 ms │
  └─────────┴────────┴────────┴────────┴────────┴───────────┴──────────┴─────────┘
  ┌───────────┬─────────┬─────────┬─────────┬─────────┬─────────┬───────┬─────────┐
  │ Stat      │ 1%      │ 2.5%    │ 50%     │ 97.5%   │ Avg     │ Stdev │ Min     │
  ├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────┼─────────┤
  │ Req/Sec   │ 325     │ 325     │ 342     │ 348     │ 341.6   │ 6.64  │ 325     │
  ├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────┼─────────┤
  │ Bytes/Sec │ 45.2 kB │ 45.2 kB │ 47.6 kB │ 48.4 kB │ 47.5 kB │ 924 B │ 45.2 kB │
  └───────────┴─────────┴─────────┴─────────┴─────────┴─────────┴───────┴─────────┘
``

기본적인 클러스터링 

```js
if (cluster.isMaster) {
    // fork()
} else {
    // do work
}
```

c내부적으로 cluster.fork() 함수는 child_process.fork() 를 사용한다.  
그러므로 마스터와 워커간의 통신 채널도 있다.  
모든 메시지를 브로드캐스팅하는 것이 가능하다.  
> Object.values(cluster.workers).forEach(worker => worker.send('message from master')


- 2차 app.js (8코어) 부하 측정
  ┌─────────┬───────┬────────┬────────┬────────┬───────────┬───────────┬─────────┐
  │ Stat    │ 2.5%  │ 50%    │ 97.5%  │ 99%    │ Avg       │ Stdev     │ Max     │
  ├─────────┼───────┼────────┼────────┼────────┼───────────┼───────────┼─────────┤
  │ Latency │ 61 ms │ 163 ms │ 295 ms │ 595 ms │ 173.34 ms │ 144.28 ms │ 2494 ms │
  └─────────┴───────┴────────┴────────┴────────┴───────────┴───────────┴─────────┘
  ┌───────────┬────────┬────────┬────────┬────────┬────────┬─────────┬────────┐
  │ Stat      │ 1%     │ 2.5%   │ 50%    │ 97.5%  │ Avg    │ Stdev   │ Min    │
  ├───────────┼────────┼────────┼────────┼────────┼────────┼─────────┼────────┤
  │ Req/Sec   │ 980    │ 980    │ 1168   │ 1235   │ 1141.6 │ 83.17   │ 980    │
  ├───────────┼────────┼────────┼────────┼────────┼────────┼─────────┼────────┤
  │ Bytes/Sec │ 136 kB │ 136 kB │ 162 kB │ 172 kB │ 159 kB │ 11.6 kB │ 136 kB │
  └───────────┴────────┴────────┴────────┴────────┴────────┴─────────┴────────┘

3배가량 성능향상  




